[https://github.com/ton-blockchain/docs/blob/master/docs/overviews/TL-B.md]

TL-B

TL-B расшифровывается как "Typed Language - Binary" (Типизированный язык - двоичный). Он используется для описания схемы (де)сериализации объектов в ячейки. В TON есть подробные и полные схемы TL-B для всех объектов.

Схема

Каждая схема TL-B состоит из деклараций. Каждое объявление описывает конструктор для некоторого типа. Например, тип Bool может иметь два конструктора для значений true и false.

Типичные декларации TL-B показаны ниже:

bool_false$0 = Bool;
bool_true$1 = Bool;

unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);

acc_trans#5 account_addr:bits256
   transactions:(HashmapAug 64 ^Transaction CurrencyCollection)
   state_update:^(HASH_UPDATE Account)
   = AccountBlock;


Каждая декларация TL-B состоит из:


Конструктор: имя конструктора, за которым сразу следует необязательный тег конструктора
список явных и неявных определений полей разделяются пробелами (" ", "\n", и т.д.)
знак =
(опционально) Имя типа


Пример: два конструктора (с разными двоичными префиксами) для типа Bool.

bool_false$0 = Bool;
bool_true$1 = Bool;


Конструктор

Конструктор объявляется через constructor_name[separator,tag].

constructor_name состоит из символов [A-z0-9_]. Обычно используются имена snake_case.

За constructor_name может следовать separator. Отсутствие separator означает, что teg будет вычислен автоматически как 32-битная crc32-сумма значений конструкторов. Если присутствует separator, он может принимать два значения # и $. Первое означает, что teg будет дан в шестнадцатеричном виде, второе - в двоичном. После обоих разделителей может стоять символ подчёркивания _, обозначающий пустой тег.

Существует также специальное имя конструктора _ (называемое анонимным конструктором), которое означает, что для данного типа существует только один неименованный конструктор с пустым тегом.

В таблице ниже приведены возможные определения тегов.


  
    
      Конструктор
      Тег
    
  
  
    
      _
      пустой тег для анонимного конструктора
    
    
      some
      автоматически вычисляемый 32-битный тег
    
 
      some#bba
      12-битный тег, равный 0b101110111010
    
        
      some$01011
      5-битный тег, равный 0b01011
    
            
      some#_
      пустой тег
    
            
      some$_
      пустой тег
    
  


Обратите внимание, что предварительно сгенерированные теги обычно не используются; предпочтительнее явное объявление.

Определения полей

Явные

Определение каждого поля имеет вид ident : type-expr, где ident - идентификатор с именем поля (заменяется подчеркиванием _ для анонимных полей), а type-expr - тип поля. Тип, представленный здесь, является выражением типа, которое может включать простые типы или параметры типов с подходящими параметрами. Переменные - т.е. (идентификаторы) ранее определенных полей типов # (натуральные числа) или Type (тип типов) - могут быть использованы в качестве параметров типов.

Существует несколько предопределенных типов:


# - означает беззнаковое 32-битное число
## N - то же, что и uintN - означает беззнаковое N-битное число
# - означает число от 0 до N (включая оба). Такое число хранится в битах ceil(log2(N+1)).
N * Bit - означает N-битный фрагмент
^Cell - означает произвольную ячейку в ссылке
^[ field_definitions ] - означает, что определения полей хранятся в ячейке со ссылками
Type - обозначает произвольный тип (но встречается только в неявных определениях).


type-expr обычно состоит из (опционально) type только как: last_trans_lt:uint64 или _:StateInit. Однако возможно, что type-expr также содержит условия. В этом случае type-expr состоит из ident, : , condition, ?, type. Если условие (которое может ссылаться на ранее определенные поля) принимает значение false, соответствующее поле не представляется. Например, prev:n?^(ProofChain n) означает, что поле prev представлено только для объектов, когда n>0.

Неявные

Некоторые поля могут быть неявными. Их определения окружены фигурными скобками, которые указывают, что поле фактически не присутствует в процессе, но его значение должно быть выведено из других данных (обычно параметров сериализуемого типа). Например

nothing$0 {X:Type} = Maybe X;
just$1 {X:Type} value:X = Maybe X;


означает следующее: какой-то другой конструктор может определить поле var:(Maybe #). В этом случае переменная будет сериализована либо как 1 бит и сериализация # (uint32), если var присутствует, либо как 0 бит, если var отсутствует. Таким образом, Maybe объявляется как C++-подобный шаблонный тип для произвольного типа X. Однако если Maybe будет объявлен как nothing$0 {X:#} = Maybe X;, это будет означать, что Maybe объявлен для произвольного числа (не полностью произвольного типа X).

Определение типа

Имя типа состоит из символов [A-z0-9_]. По соглашению это имя в CamelCase.

Он может быть задан одним или несколькими параметрами.

В некоторых случаях перед словом "variables" ставится тильда(~). Это означает, что до десериализации точное значение этой переменной неизвестно, а будет вычислено во время десериализации.

Давайте рассмотрим

unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);


и случай, когда мы хотим десериализовать объект Unary ~N из среза, содержащего битовую строку 0b111111111100101. Когда мы говорим, что хотим десериализовать Unary ~N, это означает, что мы еще не знаем, десериализуем ли мы Unary 0, Unary 7 или Unary 1020. Вместо этого мы начинаем с 0b111111111100101 и сравниваем его с префиксами конструктора 0b0 для unary_zero и 0b1 для unary_succ. Мы видим, что у нас есть unary_succ, но снова значение N не может быть выведено, вместо этого мы должны получить его из десериализации переменной x. Эта переменная имеет тип Unary ~(N-1) и значение N-1 может быть выведено из десериализации остальных битов в срезе. Получаем остальные биты среза и пытаемся десериализовать Unary ~(N-1) и снова видим тег unary_succ. Таким образом, мы рекурсивно погружаемся в Unary, пока не доберемся до Unary ~(N-8). На этом уровне мы видим, что остальная часть фрагмента начинается с тега unary_zero и, таким образом, представляет собой объект Unary 0. Вернувшись назад, мы можем получить, что изначально у нас был объект Unary 8. Таким образом, после десериализации Unary ~N из среза (0b111111111100101) мы получаем объект Unary 8 и остаток среза (0b0101), из которого могут быть десериализованы последующие переменные конструктора.

Ограничения

Некоторые неявные поля могут содержать ограничения, например, {n . Это означает, что ранее определенные переменные n и m должны удовлетворять соответствующему неравенству. Это неравенство является неотъемлемым свойством конструктора. Оно должно быть проверено при сериализации, кроме того, объекты с переменными, не удовлетворяющими ограничениям, являются недействительными.

Пример конструкторов с ограничениями:

hml_short$0 {m:#} {n:#} len:(Unary ~n) {n 

Комментарии

Схемы TL-B поддерживают C-подобные комментарии:

/* 
This is a
multiline
comment 
*/

// This is one line comment


(Де)сериализация

Учитывая схему TL-B, любой объект может быть сериализован в конструктор и десериализован из среза. В частности, при десериализации объекта необходимо начать с определения соответствующего конструктора по тегу, а затем десериализовать переменные одну за другой слева направо (рекурсивно переходя к сериализации переменных, которые сами являются объектами TL-B). При сериализации мы идем другим путем, найдя и записав тег сборщика, который соответствует данному объекту типа, а затем продолжаем слева направо записывать с каждой переменной.

Для парсеров рекомендуется читать схему один раз и генерировать сериализатор и десериализатор для каждого типа, вместо того чтобы обращаться к схеме на лету.

BNF-грамматика

Форму Backus-Naur можно найти в файле TlbParser.bnf, спасибо @andreypfau.

TL-B также поддерживается плагином intellij-ton.

Документы по TL-B можно найти в Белой книге TVM и в сжатом (собранном в одном месте) виде здесь.

Генератор сериализаторов и десериализаторов

Пример генератора, используемого самим узлом TON, можно найти в Ton node sources.