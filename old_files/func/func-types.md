[https://github.com/ton-blockchain/docs/blob/master/docs/func/types.md]

Типы

FunC имеет следующие встроенные типы:

Атомарные типы


int - это тип 257-битных знаковых целых чисел. По умолчанию проверка на переполнение включена и приводит к исключениям целочисленного переполнения.
cell - это тип ячеек TVM. Все постоянные данные в блокчейне TON хранятся в виде дерева ячеек. В каждой ячейке хранится до 1023 бит произвольных данных и до 4 ссылок на другие ячейки. Ячейки играют роль памяти в TVM на основе стека.
slice - это тип срезов ячеек. Ячейка может быть преобразована в срез, а затем биты данных и ссылки на другие ячейки из ячейки могут быть получены путем загрузки их из среза.
builder - это тип конструкторов ячеек. Биты данных и ссылки на другие ячейки могут быть сохранены в конструкторе, а затем конструктор может быть доработан до новой ячейки.
tuple - это тип хранилищ TVM. Хранилище - это упорядоченная коллекция, включающая до 255 компонентов, имеющих произвольные типы значений, возможно, различных.
cont - это тип продолжений TVM. Продолжения используются для управления потоком выполнения программы TVM. Это довольно низкоуровневый объект с точки зрения FunC, хотя, как ни парадоксально, довольно общий.


Обратите внимание, что любой из перечисленных типов занимает только одну запись в стеке TVM.

Отсутствие типа boolean (логический тип данных)

В FunC булевы числа представлены как целые числа: false представляется как 0, а true - как -1 (257 единиц в двоичной системе счисления). Логические операции выполняются как побитовые операции. Когда проверяется условие, каждое ненулевое целое число считается истинным значением.

Нулевые значения

Значением null типа TVM Null FunC представляет отсутствие значения некоторого атомарного типа. Некоторые примитивы из стандартной библиотеки могут быть типизированы как возвращающие атомарный тип и на самом деле в некоторых случаях возвращают nulls. Другие могут быть типизированы как исключающие значение атомарного типа, но прекрасно работают и с null значениями. Такое поведение явно указано в спецификации примитива. По умолчанию null значения запрещены и приводят к исключению во время выполнения.

Таким образом, атомарный тип A может быть неявно преобразован в тип A^? a.k.a. Maybe A (программа проверки типов не имеет отношения к такому преобразованию).

Тип отверстий

FunC поддерживает вывод типов. Типы _ и var представляют собой "отверстия" в типе, которые впоследствии могут быть заполнены некоторым действительным типом во время проверки типа. Например, var x = 2; - это определение переменной x, равной 2. Программа проверки типов может сделать вывод, что x имеет тип int, потому что 2 имеет тип int, а левая и правая стороны присваивания должны иметь одинаковые типы.

Типы композитов

Типы могут быть составлены в более сложные типы.

Функциональный тип

Типы вида A -> B представляют функции с заданными доменом и кодоменом. Например, int -> cell - это тип функций с одним целочисленным аргументом, которые возвращают ячейку TVM.

Внутренне значения таких типов представляются как продолжения.

Тензорные типы

Типы вида (A, B, ...) по сути представляют собой упорядоченные коллекции значений типов A, B, ..., которые все вместе занимают более одной записи стека TVM.

Например, если функция foo имеет тип int -> (int, int), это означает, что функция принимает одно целое число и возвращает их пару.

Вызов этой функции может выглядеть как (int a, int b) = foo(42);. Внутри функция потребляет одну запись стека и оставляет две.

Обратите внимание, что хотя в низкоуровневой перспективе значение (2, (3, 9)) типа (int, (int, int)) и значение (2, 3, 9) типа (int, int, int) представлены одинаково как три записи стека 2, 3 и 9, для FunC type-checker это значения разных типов: например, код (int a, int b, int c) = (2, (3, 9)); не будет скомпилирован.

Частным случаем тензорного типа является тип единицы (). Он обычно используется для представления того факта, что функция не возвращает никакого значения или не имеет аргументов. Например, функция print_int будет иметь тип int -> (), а функция random имеет тип () -> int. Он имеет уникального обитателя (), который занимает 0 записей в стеке.

Тип формы (A) рассматривается программой проверки типов как тот же тип, что и A.

Типы хранилищ

Типы вида [A, B, ...] представляют собой хранилища TVM с конкретной длиной и типами компонентов, известными во время компиляции. Например, [int, cell] - это тип хранилища TVM длиной ровно 2, первый компонент которого является целым числом, а второй - ячейкой. [] - это тип пустых хранилищ (имеющих единственного обитателя - пустого хранилища). Обратите внимание, что в отличие от типа единицы (), значение [] занимает 1 запись в стеке.

Полиморфизм с переменными типов

FunC имеет систему типов Миллера-Рабина с поддержкой полиморфных функций. Например, функция

forall X -> (X, X) duplicate(X value) {
  return (value, value);
}


это полиморфная функция, которая принимает значение (одна запись в стеке) и возвращает две копии этого значения. duplicate(6) произведет значения 6 6, а duplicate([]) произведет две копии [] [] пустого хранилища.

В данном примере X является переменной типа.

Более подробную информацию по этому вопросу можно найти в разделе "Функции".

Определяемые пользователем типы

В настоящее время FunC не имеет поддержки для определения типов, за исключением конструкций типов, описанных выше.

Ширина типа

Как вы могли заметить, каждое значение типа занимает некоторое количество записей в стеке. Если это число одинаково для всех значений типа, то оно называется шириной типа. Полиморфные функции в настоящее время могут быть определены только для типов с фиксированной и заранее известной шириной типа.