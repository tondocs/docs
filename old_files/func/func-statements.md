[https://github.com/ton-blockchain/docs/blob/master/docs/func/statements.md]

Выражения

В этом разделе кратко рассматриваются выражения FunC, представляющие собой код органов обычных функций.

Наиболее распространенным типом утверждений является выражение. Это выражение, за которым следует ;. Описание выражений было бы довольно сложным, поэтому здесь представлен только набросок.

Объявление переменной

Невозможно объявить локальную переменную, не определив ее начальное значение. Приведем несколько примеров объявления переменных:


int x = 2;
var x = 2; - этот пример уже рассматривался в разделе типов.
(int, int) p = (1, 2);
(int, var) p = (1, 2);
(int, int, int) (x, y, z) = (1, 2, 3);
(int x, int y, int z) = (1, 2, 3);
var (x, y, z) = (1, 2, 3);
(int x = 1, int y = 2, int z = 3);
[int, int, int] [x, y, z] = [1, 2, 3];
[int x, int y, int z] = [1, 2, 3];
var [x, y, z] = [1, 2, 3];


Переменная может быть "повторно объявлена" в той же области видимости. Например, вот правильный код:

int x = 2;
int y = x + 1;
int x = 3;


На самом деле второе вхождение int x - это не объявление, а просто страховка во время компиляции, что x имеет тип int. Поэтому третья строка эквивалентна простому присваиванию x = 3;.

А во вложенных диапазонах переменная может быть действительно передекларирована, как и в языке С. Например, рассмотрим код:

int x = 0;
int i = 0;
while (i 

Но, как упоминалось в разделе глобальных переменных, глобальная переменная не может быть повторно объявлена.

Обратите внимание, что объявление переменной - это оператор выражения, поэтому фактически конструкции типа int x = 2 являются полноценными выражениями. Например, вот правильный код:

int y = (int x = 3) + 1;


Это объявление двух переменных x и y, равных соответственно 3 и 4.

Знак подчеркивания

Знак подчеркивания _ используется, когда значение не нужно. Например, предположим, что функция foo имеет тип int -> (int, int, int). Мы можем получить первое возвращаемое значение и проигнорировать второе и третье следующим образом:

(int fst, _, _) = foo(42);


Применение функций

В обычном языке вызов функции выглядит так: аргументы вызова функции перечисляются после имени функции, разделяясь запятыми.

;; suppose foo has type (int, int, int) -> int
int x = foo(1, 2, 3);


Но обратите внимание, что foo на самом деле является функцией одного аргумента типа (int, int, int). Чтобы увидеть разницу, предположим, что bar - это функция типа int -> (int, int, int). В отличие от обычных языков, вы можете компоновать функции таким образом:

int x = foo(bar(42));


вместо эквивалентной, но более длинной формы:

(int a, int b, int c) = bar(42);
int x = foo(a, b, c);


Также возможны вызовы в стиле Haskell, но не всегда (будет исправлено позже):

;; suppose foo has type int -> int -> int -> int
;; i.e. it's carried
(int a, int b, int c) = (1, 2, 3);
int x = foo a b c; ;; ok
;; int y = foo 1 2 3; wouldn't compile
int y = foo (1) (2) (3); ;; ok


Лямбда-выражения

Лямбда-выражения пока не поддерживаются.

Методы вызовов

Немодифицирующие методы

Если функция имеет хотя бы один аргумент, ее можно вызвать как немодифицирующий метод. Например, store_uint имеет тип (builder, int, int) -> builder (второй аргумент - значение для хранения, а третий - длина бита). begin_cell - это функция, которая создает новый конструктор. Следующие коды эквивалентны:

builder b = begin_cell();
b = store_uint(b, 239, 8);


builder b = begin_cell();
b = b.store_uint(239, 8);


Поэтому первый аргумент функции может быть передан ей, находясь перед именем функции, если он отделен .. Код можно еще более упростить:

builder b = begin_cell().store_uint(239, 8);


Также возможны множественные вызовы методов:

builder b = begin_cell().store_uint(239, 8)
                        .store_int(-1, 16)
                        .store_uint(0xff, 10);


Модификация методов

Если первый аргумент функции имеет тип A, а возвращаемое значение функции имеет вид (A, B), где B - некоторый произвольный тип, то функция может быть вызвана как модифицирующий метод. Вызовы модифицирующих методов могут принимать некоторые аргументы и возвращать некоторые значения, но они модифицируют свой первый аргумент, то есть присваивают первый компонент возвращаемого значения переменной из первого аргумента. Например, предположим, что cs - это срез ячейки, а load_uint имеет тип (slice, int) -> (slice, int): он принимает срез ячейки и количество битов для загрузки и возвращает остаток среза и загруженное значение. Следующие коды эквивалентны:

(cs, int x) = load_uint(cs, 8);

(cs, int x) = cs.load_uint(8);

int x = cs~load_uint(8);

В некоторых случаях мы хотим использовать функцию как модифицирующий метод, который не возвращает никакого значения - только модифицирует первый аргумент. Это можно сделать с помощью единичного типа следующим образом: предположим, мы хотим определить функцию inc типа int -> int, которая увеличивает целое число, и использовать ее как модифицирующий метод. Тогда мы должны определить inc как функцию типа int -> (int, ()):

(int, ()) inc(int x) {
  return (x + 1, ());
}


Когда он определен таким образом, его можно использовать как модифицирующий метод:

x~inc();


увеличит x.

. и ~ в именах функций

Предположим, что мы хотим использовать inc как немодифицирующий метод. Мы можем написать что-то вроде этого:

(int y, _) = inc(x);


Но можно переопределить определение inc как модифицирующего метода:

int inc(int x) {
  return x + 1;
}
(int, ()) ~inc(int x) {
  return (x + 1, ());
}


а затем назвать его так:

x~inc();
int y = inc(x);
int z = x.inc();


Первый вызов изменит x, второй и третий - нет.

В общем, когда функция с именем foo вызывается как немодифицирующий или модифицирующий метод (т.е. с синтаксисом .foo или ~foo), компилятор FunC использует определение .foo или ~foo соответственно, если такое определение представлено, а если нет, то использует определение foo.

Операторы

Обратите внимание, что в настоящее время все унарные и бинарные операторы являются целочисленными операторами. Логические операторы представлены как побитовые целочисленные операторы (см. Отсутствие типа boolean).

Унарные операторы

Существует два унарных оператора:


~ - это не побитовое (приоритет 75).
- - является целочисленным отрицанием (приоритет 20).


Их следует отделить от аргументов.


- x - это нормально.
-x - не подходит (это одиночный идентификатор).


Бинарные операторы

С приоритетом 30 (лево-ассоциативный):


* - целочисленное умножение
/ - целочисленное деление (пол)
~/ - целочисленное деление (круглое)
^/ - целочисленное деление
% - это уменьшение целого числа по модулю
/% возвращает коэффициент и остаток
& - побитовое И


С приоритетом 20 (лево-ассоциативный):


+ - целочисленное сложение
- целочисленное вычитание
| побитовое OR
^ - побитовый XOR


С приоритетом 17 (лево-ассоциативный):


 - побитовый сдвиг влево
>> - побитовый сдвиг вправо
~>> - побитовый сдвиг вправо (округление)
^>> - побитовый сдвиг вправо (ceil)


С приоритетом 15 (лево-ассоциативный):


== - проверка целочисленного равенства
!= - проверка целочисленного неравенства
 - целочисленное сравнение
 - целочисленное сравнение
> - целочисленное сравнение
>= - целочисленное сравнение
 - целочисленное сравнение (возвращает -1, 0 или 1)


Они также должны быть отделены от аргументов:


x + y - это нормально.
x+y не подходит (это единичный идентификатор).


Условный оператор

Имеет обычный синтаксис. Например,

x > 0 ? x * fac(x - 1) : 1;

Он имеет приоритет 13.

Задания

Приоритет 10.

Простое присвоение = и аналоги бинарных операций: +=, -=, *=, /=, ~/=, ^/=, %=, ~%=, ^%=, , >>=, ~>>=, ^>>=, &=, |=, ^=.

Циклы

FunC поддерживает циклы repeat, while и do { ... } until. Цикл for не поддерживается.

Цикл repeat

Синтаксис - ключевое слово repeat, за которым следует выражение типа int. Повторяет код заданное количество раз. Примеры:

int x = 1;
repeat(10) {
  x *= 2;
}
;; x = 1024


int x = 1, y = 10;
repeat(y + 6) {
  x *= 2;
}
;; x = 65536


int x = 1;
repeat(-1) {
  x *= 2;
}
;; x = 1


Если количество раз меньше -2^31 или больше 2^31 - 1, выбрасывается исключение проверки диапазона.

Цикл while

Имеет обычный синтаксис. Пример:

int x = 2;
while (x 

Обратите внимание, что истинностное значение условия x  имеет тип int (см. Отсутствие типа boolean).

Цикл until

Имеет следующий синтаксис:

int x = 0;
do {
  x += 3;
} until (x % 17 == 0);
;; x = 51


Если выражения

Примеры:

;; usual if
if (flag) {
  do_something();
}


;; equivalent to if (~ flag)
ifnot (flag) {
  do_something();
}


;; usual if-else
if (flag) {
  do_something();
}
else {
  do_alternative();
}


;; Some specific features
if (flag1) {
  do_something1();
} else {
  do_alternative4();
}


Фигурные скобки необходимы. Такой код не будет скомпилирован:

if (flag1)
  do_something();


Блочные выражения

Также разрешены блочные выражения. Они открывают новую вложенную область видимости:

int x = 1;
builder b = begin_cell();
{
  builder x = begin_cell().store_uint(0, 8);
  b = x;
}
x += 1;
