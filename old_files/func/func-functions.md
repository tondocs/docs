[https://github.com/ton-blockchain/docs/blob/master/docs/func/functions.md]

Функции

Программа FunC - это, по сути, список объявлений/определений функций и объявлений глобальных переменных. В этом разделе рассматривается первая тема.

Любое объявление или определение функции начинается с общего шаблона, а затем следует одна из трех вещей:



одиночное ;, что означает, что функция объявлена, но еще не определена. Может быть определен позже в этом же файле или в каком-то другом файле, который передается компилятору FunC перед текущим. Например,
int add(int x, int y);

это простое объявление функции add типа (int, int) -> int.


определение тела функции на ассемблере. Это способ определения функций низкоуровневыми примитивами TVM для последующего использования в программе FunC. Например,
int add(int x, int y) asm "ADD";

это ассемблерное определение той же функции add типа (int, int) -> int, которая будет переведена в TVM опкод ADD.


обычное определение тела функции блочного оператора. Это обычный способ определения функций. Например,
int add(int x, int y) {
  return x + y;
}

это обычное определение функции add.



Объявление функции

Как уже говорилось, любое объявление или определение функции начинается с общего шаблона. Шаблон следующий:

[]  () 

где [ ... ] соответствуют необязательной записи.

Название функции

Имя функции может быть любым идентификатором, а также начинаться с символов . или ~. Значение этих символов объясняется в разделе выражений.

Например, udict_add_builder?, dict_set и ~dict_set являются допустимыми и различными именами функций.

Имена специальных функций

FunC (фактически ассемблер Fift) имеет несколько зарезервированных имен функций с предопределенными идентификаторами.


main и recv_internal имеют id = 0
recv_external имеет id = -1
run_ticktock имеет id = -2


В каждой программе должна быть функция с id 0, то есть функция main или recv_internal.

recv_internal вызывается, когда смарт-контракт получает входящее внутреннее сообщение, recv_external - для входящих внешних сообщений, а run_ticktock вызывается в транзакциях ticktock специальных смарт-контрактов.

Тип возврата

Возвращаемый тип может быть любым атомарным или составным типом, как описано в разделе типов. Например,

int foo();
(int, int) foo'();
[int, int] foo''();
(int -> int) foo'''();
() foo''''();


являются допустимыми объявлениями функций. Также допускается вывод типов. Например,

_ pyth(int m, int n) {
  return (m * m - n * n, 2 * m * n, m * m + n * n);
}


является допустимым определением функции pyth типа (int, int) -> (int, int, int), которая вычисляет Pythagorean triples.

Аргументы функции

Аргументы функций разделяются запятыми. Допустимые объявления аргументов следующие:


Обычное объявление: тип + имя. Например, int x - это объявление аргумента типа int и имени x в объявлении функции () foo(int x);.

Объявление неиспользуемого аргумента: только тип. Например,
int first(int x, int) {
  return x;
}

is a valid function definition of type (int, int) -> int.

Аргумент с объявлением предполагаемого типа: только имя. Например,
int inc(x) {
  return x + 1;
}

является допустимым определением функции типа int -> int. Тип int для x определяется с помощью средства проверки типов.



Обратите внимание, что хотя функция может выглядеть как функция от нескольких аргументов, на самом деле это функция от одного аргумента тензорного типа. Чтобы увидеть разницу, пожалуйста, обратитесь к применению функций. Тем не менее, компоненты тензора аргументов условно называются аргументами функции.

Спецификаторы

Существует три типа спецификаторов: impure, inline/inline_ref и method_id. Один, несколько или ни одного из них можно поместить в объявление функции, но в настоящее время они должны быть представлены в правильном порядке: например, не разрешается помещать impure после inline.

Спецификатор impure

Спецификатор impure означает, что функция может иметь некоторые побочные эффекты, которые нельзя игнорировать. Например, мы должны поставить спецификатор impure, если функция может модифицировать контрактное хранилище, отправлять сообщения или выбрасывать исключение, когда некоторые данные недействительны, и функция предназначена для проверки этих данных.

Если не указано impure и результат вызова функции не используется, то компилятор FunC может и будет удалять этот вызов функции.

Например, в функции stdlib.fc

int random() impure asm "RANDU256";


определена. impure используется потому, что RANDU256 изменяет внутреннее состояние генератора случайных чисел.

Спецификатор Inline

Если функция имеет спецификатор inline, то ее код фактически подставляется в каждом месте, где вызывается функция. Само собой разумеется, что рекурсивные вызовы inlined-функции невозможны.

Спецификатор Inline_ref

Код функции со спецификатором inline_ref помещается в выделенную ячейку, и каждый раз при вызове функции TVM выполняет команду CALLREF. Таким образом, это похоже на inline, но поскольку ячейка может быть повторно использована в нескольких местах без дублирования, почти всегда эффективнее по размеру кода использовать спецификатор inline_ref вместо inline, если только функция не вызывается ровно один раз. Рекурсивные вызовы функций inline_ref'ed по-прежнему невозможны, поскольку в ячейках TVM нет циклических ссылок.

method_id

Каждая функция в программе TVM имеет внутренний целочисленный идентификатор, по которому ее можно вызвать. Обычные функции нумеруются последующими целыми числами, начиная с 1, но get-методы контракта нумеруются по crc16 хэшам их имени.  Спецификатор method_id() позволяет установить id функции в указанное значение, при этом method_id использует значение по умолчанию (crc16() & 0xffff) | 0x10000. Если функция имеет спецификатор method_id, то она может быть вызвана в lite-client или ton-explorer как get-метод по своему имени.

Например,

(int, int) get_n_k() method_id {
  (_, int n, int k, _, _, _, _) = unpack_state();
  return (n, k);
}


это метод получения контракта multisig.

Полиморфизм с помощью forall

Перед объявлением или определением любой функции может быть декларатор переменных типа forall. Он имеет следующий синтаксис:

forall  ->

где имя переменной типа может быть любым идентификатором. Обычно они называются заглавными буквами.

Например,

forall X, Y -> [Y, X] pair_swap([X, Y] pair) {
  [X p1, Y p2] = pair;
  return [p2, p1];
}


это функция, которая принимает виток длиной ровно 2, но со значениями любых (с одной записью в стеке) типов в компонентах, и меняет их местами.

pair_swap([2, 3]) даст [3, 2], а pair_swap([1, [2, 3, 4]]) даст [[2, 3, 4], 1].

В данном примере X и Y являются переменными типа. Когда функция вызывается, переменные типа заменяются фактическими типами и выполняется код функции. Обратите внимание, что хотя функция является полиморфной, фактический ассемблерный код для нее одинаков для каждой подстановки типов. Это достигается в основном за счет полиморфизма примитивов манипулирования стеком. В настоящее время другие формы полиморфизма (например, полиморфизм ad-hoc с классами типов) не поддерживаются.

Также стоит отметить, что ширина типов X и Y должна быть равна 1, то есть значения X или Y должны занимать одну запись в стеке. Поэтому вы не можете вызвать функцию pair_swap для связки типа [(int, int), int], потому что тип (int, int) имеет ширину 2, т.е. занимает 2 записи в стеке.

Определение тела функции ассемблера

Как упоминалось выше, функция может быть определена ассемблерным кодом. Синтаксис представляет собой ключевое слово asm, за которым следует одна или несколько команд ассемблера, представленных в виде строк. Например, можно определить

int inc_then_negate(int x) asm "INC" "NEGATE";

- функция, которая увеличивает целое число, а затем отрицает его. Вызовы этой функции будут транслироваться в 2 ассемблерные команды INC и NEGATE. Альтернативный способ определения функции

int inc_then_negate'(int x) asm "INC NEGATE";


INC NEGATE будет рассматриваться FunC как одна команда ассемблера, но это нормально, потому что ассемблер Fift знает, что это 2 отдельные команды.

Список команд ассемблера можно найти здесь: Инструкции TVM.

Перестановка записей в стеке

В некоторых случаях мы хотим передать аргументы в ассемблерную функцию не в том порядке, в котором требует ассемблерная команда, или/и получить результат в другом порядке записей в стеке, чем возвращает команда. Мы можем вручную перестроить стек, добавив соответствующие стековые примитивы, но FunC может сделать это автоматически.

Например, предположим, что ассемблерная команда STUXQ принимает integer, builder и integer и возвращает builder вместе с целочисленным флагом, указывающим на успех или неудачу операции. Мы можем определить функцию

(builder, int) store_uint_quite(int x, builder b, int len) asm "STUXQ";


Однако, предположим, что мы хотим переставить аргументы. Тогда мы можем определить

(builder, int) store_uint_quite(builder b, int x, int len) asm(x b len) "STUXQ";


Поэтому вы можете указать необходимый порядок аргументов после ключевого слова asm.

Также мы можем переставить возвращаемые значения следующим образом:

(int, builder) store_uint_quite(int x, builder b, int len) asm( -> 1 0) "STUXQ";


Числа соответствуют индексам возвращаемых значений (0 - самая глубокая запись в стеке среди возвращаемых значений).

Также возможно комбинирование этих методов:

(int, builder) store_uint_quite(builder b, int x, int len) asm(x b len -> 1 0) "STUXQ";


Многострочные команды

Многострочные команды ассемблера или даже фрагменты Fift-кода могут быть определены с помощью многострочных строк, которые начинаются и заканчиваются символом """.

slice hello_world() asm """
  "Hello"
  " "
  "World"
  $+ $+ $>s
  PUSHSLICE
""";
