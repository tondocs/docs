[https://github.com/ton-blockchain/docs/blob/master/docs/func/literals_identifiers.md]

Литералы и идентификаторы

Числовые литералы

FunC позволяет использовать десятичные и шестнадцатеричные целочисленные литералы (ведущие нули разрешены).

Например, 0, 123, -17, 00987, 0xef, 0xEF, 0x0, -0xfFAb, 0x0001, -0, -0x0 являются допустимыми литералами чисел.

Строковые литералы

Строки в FunC заключаются в двойные кавычки " типа "this is a string". Специальные символы типа \n и многострочные строки не поддерживаются. Опционально строковые литералы могут указывать тип после себя, например, "string"u.

Поддерживаются следующие типы строк:


без типа - используется для определения функций asm и для определения среза const строкой ASCII,
s - определяет необработанный фрагмент const его содержимым (в шестнадцатеричной кодировке и, по желанию, с битовой добавкой),
a - создает фрагмент const, содержащий структуру MsgAddressInt, по указанному адресу,
u - создает константу int, соответствующую шестнадцатеричным значениям предоставленной ASCII-строки,
h - создает int const, который является первыми 32 битами SHA256 хэша строки,
H - создает константу int, которая является всеми 256 битами SHA256 хэша строки,
c - создает константу int, которая является crc32 значением строки.


For example, following values result in the corresponding consts:


"string" становится x{737472696e67} срезом const,
"abcdef "s становится x{abcdef} срезом const,
"Ef8zMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM0vF "a становится x{9FE666666666666666666666666666666666666666666666666666667_} срезом const ( addr_std$10 anycast:none$0 workchain_id:int8=0xFF address:bits256=0x33...33),
"NstK "u становится 0x4e73744b int const,
"transfer(slice, int) "h становится 0x7a62e8a8 int const,
"transfer(slice, int) "H становится 0x7a62e8a8ebac41bd6de16c65e7be363bc2d2cbc6a0873778dead4795c13db979 int const,
"transfer(slice, int) "c становится 2235694568 int const.


Идентификаторы

FunC позволяет использовать действительно широкий класс идентификаторов (имен функций и переменных). А именно, любая (однострочная) строка, которая не содержит специальных символов ;, , , (, ), (пробел или табуляция), ~ и ., не начинается как комментарий или строковый литерал (с "), не является числовым литералом, не является символом подчеркивания _ и не является ключевым словом, является допустимым идентификатором (с единственным исключением, что если она начинается с `, она должна заканчиваться тем же ` и не может содержать никаких других `, кроме этих двух).

Также имена функций в определениях функций могут начинаться с . или ~.

Например, это действительный идентификатор:


query, query', query''
elem0, elem1, elem2
CHECK
_internal_value
message_found?
get_pubkeys&signatures
dict::udict_set_builder
_+_ (стандартный оператор сложения типа (int, int) -> int в префиксной нотации, хотя он уже определен)
fatal!


' в конце имени переменной условно используется, когда вводится некоторая модифицированная версия старого значения. Например, почти все модифицирующие встроенные примитивы для работы с хэшмапами (кроме тех, что имеют префикс ~) принимают хэшмап и возвращают новую версию хэшмапа вместе с некоторыми другими данными, если это необходимо. Удобно называть эти значения одним и тем же именем с суффиксом '.

Суффикс ? обычно используется для булевых переменных (в TVM нет встроенного типа bool; bool представлены целыми числами: 0 - false, -1 - true) или для функций, возвращающих некоторый флаг, обычно указывающий на успех операции (например, udict_get?).

Это недействительные идентификаторы:


take(first)Entry
"not_a_string
msg.sender
send_message,then_terminate
_


Еще несколько необычных примеров допустимых идентификаторов:


123validname
2+2=2*2
-alsovalidname
0xefefefhahaha
{hehehe}
pa{--}in"`aaa`"


Такие идентификаторы также не являются действительными:


pa;;in"`aaa`" (потому что ; запрещено)
{-aaa-}
aa(bb
123 (это число)


Также FunC имеет специальный тип идентификаторов, которые заключаются в обратные кавычки `. В кавычках разрешены любые символы, кроме \n и самих кавычек.

Например, `I'm a variable too` является допустимым идентификатором, также как и `any symbols ; ~ () are allowed here...`.

Константы

FunC позволяет определить константы времени компиляции, которые подставляются и предварительно вычисляются во время компиляции.

Константы определяются как const optional-type identifier = value-or-expression;, optional-type можно использовать для принудительного выбора определенного типа константы и для лучшей читабельности.

На данный момент поддерживаются типы int и slice.

value-or-expression может быть литералом или предварительно вычисляемым выражением литералов и констант.

Например, константы могут быть определены следующим образом:


const int101 = 101; определяет константу int101, которая эквивалентна числовому литералу 101,
const str1 = "const1", str2 = "aabbcc"s; определяет две константы, которые равны соответствующим строкам,
const int int240 = ((int1 + int2) * 10)  определяет константу int240, которая равна результату вычисления,
const slice str2r = str2; определяет константу str2r, которая равна значению константы str2.


Поскольку числовые константы подставляются во время компиляции, все оптимизации и предварительные вычисления, выполняемые во время компиляции, успешно выполняются (в отличие от старого метода определения констант через встроенные переменные PUSHINTs).